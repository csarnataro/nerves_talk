defmodule PomodoroTimer do
  @moduledoc """
  Documentation for `PomodoroTimer`.
  """
  alias Circuits.GPIO

  require Logger

  @behaviour :gen_statem

  @name :pomodoro_timer

  # in seconds
  @initial_time 6
  # in seconds
  @short_break 2
  # in seconds
  @long_break 4

  @button_gpio 4

  def child_spec(args) do
    %{
      id: __MODULE__,
      start: {__MODULE__, :start_link, [args]},
      restart: :permanent,
      shutdown: 5000,
      type: :worker
    }
  end

  # @one_second 1_000

  # def start_link([]) do
  #   GenServer.start_link(__MODULE__, [], name: __MODULE__)
  # end

  # @impl true
  # def init(opts) do
  #   Process.send_after(self(), :tick, @one_second)

  #   {:ok, opts}
  # end

  # @impl true
  # def handle_info(:tick, state) do
  #   time = Calendar.strftime(DateTime.utc_now() |> DateTime.shift(hour: 2), "%d/%m/%Y %H:%M:%S")

  #   write(time, 10, 4, true)

  #   Process.send_after(self(), :tick, @one_second)

  #   {:noreply, state}
  # end

  defp write(text, x \\ 0, y \\ 0, clear_screen \\ false) do
    PomodoroTimer.ArrayServer.write(text, x, y, clear_screen)
  end

  @doc ~S"""

  ## Client API
  ### Usage:

    iex > CountDownCounter.start

    iex > CountDownCounter.stop


  """
  def start_link(_) do
    :gen_statem.start({:local, @name}, __MODULE__, %{time: @initial_time, round: 4}, [])
  end

  def push_button do
    :gen_statem.cast(@name, :push_btn)
  end

  def stop do
    :gen_statem.stop(@name)
  end

  # :gen_statem behaviour's implementations
  @impl :gen_statem
  def terminate(_reason, _state, _data) do
    IO.write("Terminating state machine")
    write("Terminating state machine with status: ", 10, 4, true)
  end

  @impl :gen_statem
  def callback_mode, do: :state_functions

  @impl :gen_statem
  def init(data) do
    IO.puts("Count is #{Map.get(data, :time)}")
    write("Count is #{Map.get(data, :time)}", 10, 4, true)
    actions = [{:next_event, :internal, :push_btn}]

    {:ok, button_gpio} = GPIO.open(@button_gpio, :input, pull_mode: :pullup)
    GPIO.set_interrupts(button_gpio, :both)

    # adding gpio to state, otherwise it will be garbage collected
    data = data |> Map.put(:gpio, button_gpio)
    {:ok, :idle, data, actions}
  end

  # interrupt on button
  def handle_info({:circuits_gpio, @button_gpio, _timestamp, 0}, data) do
    IO.puts("Button is: [pressed]")
    write("PRESSED", 10, 20, false)

    actions = [
      {:timeout, 1000, :short_break}
    ]

    data =
      data
      |> Map.update(:time, 0, fn _ -> @initial_time end)
      |> Map.update(:round, 0, fn prev -> prev - 1 end)

    {:next_state, :idle, data, actions}
  end

  def handle_info({:circuits_gpio, @button_gpio, _timestamp, 1}, data) do
    actions = [
      {:timeout, 1000, :short_break}
    ]

    data =
      data
      |> Map.update(:time, 0, fn _ -> @initial_time end)
      |> Map.update(:round, 0, fn prev -> prev - 1 end)

    {:next_state, :idle, data, actions}

  end

  # states

  # initial state (automatically triggered)
  def idle(:internal, :push_btn, data) do
    write(">>> PUSHED BUTTON", 10, 4, true)
    IO.puts(">>> PUSHED BUTTON")
    actions = [{:timeout, 1000, :one_second}]
    data = Map.update(data, :time, 0, fn prev -> prev - 1 end)
    {:next_state, :counting, data, actions}
  end

  # initial state, triggered by pushing a button
  def idle({:call, from}, :push_btn, data) do
    actions = [
      {:timeout, 1000, :one_second},
      {:reply, from, :ok}
    ]

    data = Map.update(data, :time, 0, fn prev -> prev - 1 end)
    {:next_state, :counting, data, actions}
  end

  # initial state, triggered by timeout
  def idle(:timeout, :short_break, data) do
    write(">>> AUTOMATICALLY RESTARTED", 10, 4, true)
    IO.puts(">>> AUTOMATICALLY RESTARTED")
    actions = [{:timeout, 1000, :one_second}]
    data = Map.update(data, :time, 0, fn prev -> prev - 1 end)
    {:next_state, :counting, data, actions}
  end

  def idle(_event, _content, _data), do: :keep_state_and_data

  def counting(:timeout, :one_second, %{:time => 0} = data) do
    actions = [{:next_event, :internal, :restart}]
    {:next_state, :pause, data, actions}
  end

  def counting(:timeout, :one_second, data) do
    write("Count: #{data |> Map.get(:time)}, round: #{data |> Map.get(:round)}", 10, 4, true)
    IO.puts("Count: #{data |> Map.get(:time)}, round: #{data |> Map.get(:round)}")
    data = Map.update(data, :time, 0, fn prev -> prev - 1 end)
    actions = [{:timeout, 1000, :one_second}]
    {:keep_state, data, actions}
  end

  def counting(event_type, event, data) do
    IO.puts("in counting... #{event_type} -> #{event}")
    actions = [{:next_event, :internal, :push_btn}]
    {:keep_state, data, actions}
  end


  def pause(:internal, :restart, data) do
    write("Time to rest", 10, 4, true)
    IO.puts("Time to rest")

    actions = [
      {:timeout, @short_break * 1000, :short_break}
    ]

    data =
      data
      |> Map.update(:time, 0, fn _ -> @initial_time end)
      |> Map.update(:round, 0, fn prev -> prev - 1 end)

    {:next_state, :idle, data, actions}
    ### uncomment the next lines to make it stop automatically
    # :stop
  end
end
